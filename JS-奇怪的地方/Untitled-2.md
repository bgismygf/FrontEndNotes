
2-1 語法解析器:你寫的程式碼，轉換成電腦能讀取，兩者之間就是編譯噐。

    詞彙環境:是在討論:它被寫在哪?它的周圍環境是什麼?

    執行環境:你寫的程式碼，正在執行程式碼。

2-2 課程會花多時間在物件上，首先要了解:
    
    一個名稱會對應到唯一的值，

    名稱可能被定義很多次，但只能有一個值，

    一個名稱裡也會多個名稱和值，或是另個物件，例:

    Address:{
        Street:'Main'
        Number:100,
        Apartment:
        {
            Floor:3,
            Number:301
        }
    }

2-3 此小節是關於全域的環境和物件，全域代表任何地方都能取用它，

    所以全域執行環境創造兩件事情，全域物件和特殊變數 this，

    這是 JavaScript 幫你建立好的，在空的網頁執行開發者工具，

    輸入 this 會出現 window 物件，也就是全域物件，(如果是執行 node.js

    ，不會是 window 物件，是不同的物件)，如果開分頁，就會有另一個全域物件，

    因為每個視窗有自己的執行環境和全域物件，當你創造的變數、函數、物件不在函數裡，在全域都能看到。

2-4 此小節是關於函數和變數的順序，
    
    在順序是先呼叫，例:b();
    
    後創造，例:function b(){...略} 的情況是可行，

    稱為提升，提升並不是字面上真的移動程式碼，
    
    而是會去執行存在記憶體裡你所創造的程式碼，

    函數已經在記憶體執行過，可直接呼叫執行，

    但變數不同，JS 空出記憶體空間給變數，變數是 undefined，
    
    但要等到被執行，才會知道是什麼值，
    
    (對( = )等號的特別待遇) 因次出現 undefind。

2-5 JS 裡的 undefined 是特殊值，是表示變數還沒被設定，

    不同於出現錯誤紅字的: is not defined，這是指沒宣告。

2-6 先創造，在執行，一行行上到下執行。

2-7 單執行緒:一次執行一個指令，
    
    同步執行:程式其中一行一次執行一個，照順序。

2-8 invocation:執行或呼叫函數，

    一開始會創造全域執行環境(window 物件)，所創造的函數會在記憶體，

    但還沒呼叫所以不會執行，當呼叫，新的執行環境就會放進執行堆中，

    "堆"就是一層層，底層是全域，最上層就是正在執行的東西，每次呼叫，放進

    就創造一個新的執行環境，往上面疊進執行堆，新的執行環境和全域一樣，
    
    有自己的記憶體空間給變數和函數，呼叫下一個，就會停止，創造另一個執行環境，

    執行。

2-9 變數環境:創造變數的位置，記憶體中和其他變數關係。

    當開始執行，先從全域，也就是創造的變數，例:var myVar = 1;

    用函數去更改，例:var myVar = 2;console.log(myVar);

    得到 2，在函數外 console.log(myVar); 得到 1，

    原因是:回應 1 的 console.log 是在全域執行，

    而函數執行完就就離開執行堆，就不見了，執行換成全域。

2-10 當全域有 var myVar = 1;

    函數裡是 console.log(myVar);

    得到結果是 1，原因是執行函數，也就是新的執行環境裡沒有 myVar，

    則會他的外部環境 - 全域 去取得，這與執行環境有關，與寫在哪無關，

    如果是函數 A 裡有函數B 和 myVar，執行函數 B 的 console.log(myVar);
    
    則會去取 函數 A 的 myVar，如果函數 A 沒有，就往函數 A的外面找，也就是全域，
    
    這整條鏈子叫做範圍鏈。
    
    如果在全域呼叫函數 A 裡的函數 B 是找不到的，因為全域環境沒有函數 B。

2-11 範圍是變數可以取用的區域。

    ES6 版本裡的新的宣告變數方法:let，
    
    可像 var 一樣使用，但不是取代，

    let 讓 JS 引擎使用一種叫做區塊範圍，

    一樣創造、放入記憶體、值為 undefied，

    直到執行，真的宣告才使用 let，而 let 只存在在大括號，

    像是 if、for迴圈跑完就消失，後面課程將提到。

2-12 非同步:一段程式碼執行時會開時執行另一段程式碼然後再執行別的程式碼。

    在 JS 引擎請求瀏覽器是非同步(要資料、要畫面等等)，只有 JS 是同步的，

    假設資料再處理，有人做點擊按鈕執行函數，會發生什麼?因為這是非同步處理，

    在先前學的執行堆，先是執行環境被創造，函數被呼叫執行，在執行堆最上面，

    結束離開執行堆，而 JS 引擎的等待列稱為:事件佇列 (event queue)，

    當瀏覽器，在 JS 引擎外某處有個需要被通知的事件，例:click，
    
    在 JS 引擎裡，會被放到佇列裡，
    
    當執行堆空時，JS 會注意事件佇列，會去看是否有函數被佇列裡的事件觸發，

    所以這不是真正的非同步，因為還是一行行執行。

    時間函數可以干擾事件，非同步回呼，在 JS 是可能的。

